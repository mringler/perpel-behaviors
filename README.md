Collection of PHP Propel behaviors.

Installation
------------

From command line:

```bash
composer config repositories.repo-name vcs https://github.com/mringler/propel-behaviors
composer require mringler/propel-behaviors:dev-main
```

Or adding manually to composer.json before running `composer update`:

```json
{
  "require": {
    "mringler/propel-behaviors": "dev-master"
  },
  "repositories": {
    "repo-name": {
      "type": "vcs",
      "url": "https://github.com/mringler/propel-behaviors.git"
    }
  }
}
```
---------

Generate intl-date-getters
==================================

The getters for date columns generated by Propel can be used to get formatted date strings. However, as the default implementation uses `DateTime::format()`, no matter what locale is set, day and month names are always given in English.

With this behavior, additional getters are generated that use `strftime()` and thus use local day and month names.

Example
-------

```php
setlocale(LC_ALL, 'de_DE');   // set locale different from english

$dateFormat = 'l s. F Y';
echo $modelObject->getMyDateColumn($dateFormat); // still outputs english day and month names, i.e. "Monday, 9. January 2021"

$strftimeFormat = '%A, %e. %B %Y';
echo $modelObject->getMyDateColumnUsingLocale($strftimeFormat); // outputs localized day and month, i.e. "Montag, 9. Januar 2021"
```


Usage
-----

Add behavior declaration in `schema.xml`:

```xml
<table name="MyTable">
  <column name="my_timestamp" phpName="MyTimestamp" type="TIMESTAMP" />
  <column name="my_datetime" phpName="MyDatetime" type="DATETIME" />
  <column name="my_date" phpName="MyDate" type="DATE" />
  ...
  <behavior name="intl-date-getters"/>
</table>
```

After rebuilding the model with `propel model:build`, the base model class will have additional methods for every column in the table with a time-based type: 

```php
MyTable::getMyTimestampUsingLocale($format=null);
MyTable::getMyDatetimeUsingLocale($format=null);
MyTable::getMyDateUsingLocale($format=null);
```

Recognized types are DATE, DATETIME and TIMESTAMP.

Adjust method name
---------

The generated method name can be adjusted by supplying a format string through the "function_name_format" parameter.

The format string must contain exaclty one "%s", which will be replaced by the name of the column.

For example, to generate methods like `MyTable::getMyColumnUsingStrftime($format=null)`, set it to "`get%sUsingStrftime`":

```xml
<behavior name="intl-date-getters">
  <parameter name="function_name_format" value="get%sUsingStrftime" />
</behavior>
```

Specify columns
---------

To generate the localized getters for only some columns, use the `columns` parameter:

```xml
<table name="MyTable">
  ...
  <behavior name="intl-date-getters">
    <parameter name="columns" value="my_datetime, my_date" />
  </behavior>
</table>
```

-----------------
-------------------

Auditable
==================================

Creates a table storing audit information for the table holding the behavior.

CRUD operations on the audited table will automatically create entries in an automatically generated audit table, describing the change.

### Parameters
The behavior accepts most of the parameters from synced table behavior (see #10). Additionally, auditable behavior uses these parameters: 

| Parameter                      | Value           | Description | Default     |
|--------------------------------|-----------------|-------------|-------------|
| id_field_name | literal | Name of the id column in the audit table | `audit_id` |
| audited_at_field_name | literal | Name of the column storing the audit timestamp | `audited_at` |
| audit_event_field_name | literal | Name of column storing the audit event (insert, update, delete) | `audit_event` |
| changed_values_field_name | literal | Name of the column storing the changed values | `changed_values` |
| changed_values_field_type | literal | Propel text column type of the changed values column | `JSON` |
| changed_values_field_size | number | Size of the changed values column | `null` |
| ignore_fields | CSV | Names of columns that are not part of the audit | `null` |
| omit_value_fields | CSV |  Names of columns where audit should not include column value (like passwords) | `null` |
| omit_value_types | CSV | Propel column types where audit should not include column value | `BLOB, CLOB` |
| omit_value | string | The default placeholder used for values of omitted fields and types in the audit | `changed` |
| audited_columns_on_insert | CSV | By default, the insert audit is empty, this parameter allows to specify columns that should be added. | `null` |
| cascade_delete | `true`\|`false` | Remove audit when source row is deleted. | `false` |
| add_aggregation_to_source | literal\|`true`\|`false`| Adds a column storing the number of audits for each row to the source table. Value is either name of column or "true" for "number_of_audits". | `false` |

<hr/>

This implementation is somewhat specific, in that it tries to avoid duplicating the whole row data on input. Subsequent updates store the overridden values, which allows to rebuilt the row history backwards from the current row data. This approach has benefits, but it comes at a cost, particularly its fragility to manual row updates without audits.

The problem with manual updates that don't add audits are not just unaccounted, but they lead to wrong audits. Currently, the stored data of an audit would look something like this:

| TYPE | USER | VALUES |
| --- | --- | --- |
| insert | A | |
| update | B | fruit=apple |
 
The recorded values are the ones being overridden by the update, which is why no values need to be recorded on insert. If current value of the fruit column is "orange", you would get this audit:
- user A inserted fruit=apple
- user B updated fruit=orange

However, the actual events with manual update might have been:
- user A inserted fruit=null
- manual update fruit=apple
- user B updated fruit=pear (storing override of value "apple")
- manual update fruit=orange

So instead of showing unaccounted changes, the audit just claims that the users inserted data which they did not insert. This is very dicey, if acceptable at all.

Having to rebuild the audit after reading it from DB adds another layer of possible mistakes and errors. 

<hr/>

The clean approach would be to store the new values, instead of the overridden ones:

| TYPE | USER | VALUES |
| --- | --- | --- |
| insert | A | fruit=null |
| update | B | fruit=orange |

possibly even the old values if you want to have at least some idea about manual updates:

| TYPE | USER | OLD  | NEW |
| --- | --- | --- | --- |
| insert | A | | fruit=null |
| update | B | fruit=apple | fruit=pear |

With this, the reported user input is always correct, even if the values do not match the row values due to manual updates.
 
However, this requires to duplicate all values on input, even when you know that most values will never change.

So if you know that there are no manual updates (or those updates also add audits), the first approach is more efficient, as it allows for faster inserts and requires less space.

<hr/>

Looking back, going the easy route would have spared me time and nerves, but I really didn't want to make full duplicates (I am dealing with rather large text columns that typically won't change after insert).
But with all the caveats and sensibilities, I am not sure if this works in a general case.

----------------
---------------

License
-------

See the [LICENSE](LICENSE) file.
